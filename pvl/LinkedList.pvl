class LinkedList {
  
  Node first;

  resource state() = Perm(first, 1) ** first->state();

  requires state();
  seq<int> contents() = 
      first == null
      ? seq<int>{}
      : first.contents(); 

  ensures state();
  ensures first == null;
  LinkedList() {
    first = null;
    fold state();
  }

  void test() {
    LinkedList queue = new LinkedList();
    assert queue.contents() == seq<int>{};

    Integer i = queue.peek();
    assert i == null;

    Integer j = queue.poll();
    assert j == null;

    assert queue.contents() == seq<int>{};
    boolean b = queue.offer(3);
    Integer k = queue.peek();
    assert k.val == 3;
   
    b = queue.offer(5);
    Integer l = queue.peek();
    assert l.val == 3;

    Integer m = queue.poll();
    assert m.val == 3;

    Integer n = queue.poll();
    assert n.val == 5; 
  }

  requires Perm(first, 1) ** first->state();
  ensures Perm(first, 1) ** first != null ** first.state(); 

  ensures \old(first) != null ==> first.contents() == \old(first.contents()) + seq<int>{val};
  ensures \old(first) == null ==> first.contents() == seq<int>{val};
  void linkLast(int val) {
    if (first == null) {
      first = new Node(val, null);
    } else {
      first.append(new Node(val, null));
    }
  }

  requires Perm(first, 1) ** first != null ** first.state();
  ensures  Perm(first, 1) ** first->state();
  ensures  \result == \old(unfolding first.state() in first.val);
  ensures  first == \old(unfolding first.state() in first.next);
  ensures contents() == \old(tail(contents()));
  int unlinkFirst() {
    unfold first.state();
    int value = first.val; 
    first = first.next;
    return value;
  }
  
  requires state();
  ensures state();    
  ensures first == (\old(first));
  ensures contents() == \old(contents());
  ensures \result != null ==> Perm(\result.val, 1);
  ensures \result != null ==> \result.val == head(contents());
  ensures \old(first) == null ==> \result == null;
  ensures \old(first) != null ==> \result != null && \result.val == \old(unfolding first.state() in first.val);
  Integer peek() {
    Integer res;

    unfold state();
    if (first == null) {
      res = null;
    } else {
      unfold first.state();
      res = new Integer(first.val);
      fold first.state();
    }
    fold state();

    return res;
  }

  requires state();
  ensures state();
  ensures \result != null ==> Perm(\result.val, 1);
  ensures \old(first) == null ==> \result == null;
  ensures \old(first) != null ==> \result != null && \result.val == \old((unfolding first.state() in first.val));
  ensures \old(first) != null ==> (first) == (\old(unfolding first.state() in first.next));
  ensures \result != null ==> \result.val == head(\old(contents()));
  ensures \result == null ==> contents() == \old(contents());
  ensures \result != null ==> contents() == \old(tail(contents()));
  Integer poll() {
    Integer res;

    unfold state();
    if (first == null) {
      res = null;
    } else {
      res = new Integer(unlinkFirst());
    }
    fold state();

    return res;
  }

  requires state();
  ensures state();  
  ensures contents() == \old(contents()) + seq<int>{\old(i)}; 
  ensures \result == true;
  boolean offer(int i) {
    unfold state();
    linkLast(i);
    return true;
  }

}

class Integer {
  int val;

  ensures Perm(this.val, 1) ** this.val == val; 
  Integer(int val) {
    this.val = val;
  }
}

class Node {
  Node next;
  int val;

  resource state() = Perm(val, 1) ** Perm(next, 1) ** next->state();

  requires state();
  seq<int> contents() =
    unfolding state() in (
    next == null
      ? seq<int>{val}
      : seq<int>{val} + next.contents()
    );

  requires next->state();
  ensures state();
  ensures unfolding state() in (this.val == val && this.next == next);
  ensures contents() == (seq<int>{val} + (next == null ? seq<int>{} : \old(next.contents()))); 
  Node(int val, Node next) {
    this.val = val;
    this.next = next;
    fold state();
  }

  requires state() ** n != null ** n.state();
  ensures state();
  ensures contents() == (\old(contents()) + \old(n.contents()));
  void append(Node n) {
    unfold state();

    if (next == null) {
      next = n;
    } else {
      next.append(n);
    }

    fold state();
  }
}
