class Queue {
  
  int capacity;
  Node first;
  LockableInteger count;
  LockSymbol putLock; // lock that can guard not going over max capacity
  LockSymbol takeLock; // lock that can guard not taking empty elements.
  LockSymbol notFull;

  resource state() = Perm(first, 1) ** first->state() ** Value(capacity) ** Perm(count, 1) ** count.lock_invariant() ** Perm(putLock,1) ** Perm(takeLock,1);

  requires state();
  seq<int> contents() = 
      first == null
      ? seq<int>{}
      : first.contents(); 


  resource lock_invariant()= true;

  ensures state();
  ensures first == null;
  ensures this.capacity == capacity;
  ensures count != null ** count.lock_invariant() ** count.val == 0;
  Queue(int capacity) {
    first = null;
    this.capacity = capacity;
    this.count = new LockableInteger(0);
    putLock = new LockSymbol();
    takeLock = new LockSymbol();
    notFull = new LockSymbol();
    fold state();
  }

  // private void insert(E x) { ... } in java
  // just adds element to the end with:
  //    last = last.next = new Node<E>(x);
  // this was our variant in previous version to do that.
  // this method did not look at the size of items.
  // that should be handled by the caller of this method.
  requires state();
  ensures  state() ** first != null;
  ensures  \old(|contents()|) == 0 ==> contents() == seq<int>{val};
  ensures  \old(|contents()|) != 0 ==> contents() == \old(contents()) + seq<int>{val};
  void linkLast(int val) {
    if (first == null) {
      first = new Node(val, null);
    } else {
      first.append(new Node(val, null));
    }
  }

  /*
  requires state()
  void put(int e)
  {
    int c =-1;
    //if (held(putLock)) {}

    while(isFull())
    {

    }
  }
  */
  // With atomic int you do count.get() == capacity.


  requires state();
  ensures state() ** \result == (count.val == capacity);
  boolean isFull()
  {
    lock count;
    boolean ret = count.val == capacity;
    unlock count;
    return ret;
  }

  /*

  requires state() ** first != null;
  ensures  state();
  ensures  \result == \old(head(contents()));
  ensures  contents() == \old(tail(contents()));
  int unlinkFirst() {
    unfold first.state();
    int value = first.val; 
    first = first.next;
    return value;
  }
  
  requires state();
  ensures  state();    
  ensures  contents() == \old(contents());
  ensures  |contents()| == 0 ==> \result == null;
  ensures  |contents()| != 0 ==> \result != null ** Value(\result.val) ** \result.val == head(contents());
  Integer peek() {
    Integer res;

    if (first == null) {
      res = null;
    } else {
      unfold first.state();
      res = new Integer(first.val);
      fold first.state();
    }

    return res;
  }

  requires state();
  ensures  state();
  ensures  \old(|contents()|) == 0 ==> \result == null;
  ensures  \old(|contents()|) != 0 ==> \result != null ** Value(\result.val) ** \result.val == \old(head(contents()));
  ensures  \result == null ==> contents() == \old(contents());
  ensures  \result != null ==> contents() == \old(tail(contents()));
  Integer poll() {
    Integer res;

    if (first == null) {
      res = null;
    } else {
      res = new Integer(unlinkFirst());
    }

    return res;
  }

  requires state();
  ensures  state();  
  ensures  contents() == \old(contents()) + seq<int>{\old(i)}; 
  ensures  \result == true;
  boolean offer(int i) {
    linkLast(i);
    return true;
  }
*/
}
